비전공자가 BFS, DFS, Dijkstra를 공부하며 생겼던 의문

트리와는 다르게, 그래프는 cycle이 존재할 수 있다.
그렇기에, 이미 방문한 노드를 재방문하지 않도록 알고리즘을 설계해야, 사이클에 빠져 무한히 검색하는 일이 일어나지 않는다.
재방문하지 않는데, BFS DFS 그리고 Dijkstra를 통해 어떻게 최단 거리를 계산할 수 있을까?
언뜻 봤을 때는, 재방문하지 않기 때문에 누락되는 경로가 있을것처럼 보이지 않는가?
곰곰히 생각해본 결과, 누락되지 않음을 보일 수 있었다. 짧게 요약하면, 재방문하지 않아도 모든 경로를 고려할 수 있고, 거리 계산이 가능하기 때문이다. 이를, 조금 더 자세히 살펴보자.

이에 앞서, 편의를 위해 몇몇 개념들을 정의하겠다.
탐색을 시작할 때, 처음 방문하는 노드를 "시작 노드"라 부르자.
그리고, "시작 노드"에서 "목표 노드"로 가는 최단 경로의 길이를 구한다 해보자.
또한, "시작 노드" -> 노드1, "시작 노드" -> 노드3 -> 노드1과 같이, "시작 노드"에서 특정 노드로 가는 2개 이상의 path가 존재할 때, 해당 노드를 "중복 노드"라 말하자.
재방문을 방지하는 메커니즘이, 위의 "중복 노드"를 한번만 방문하도록 강제함으로서 작동함에 주목하자.

이제, 아래의 세 경우로 나누어 생각해보자.

첫째, 최단 경로 P에 "중복 노드"가 포함되지 않는 경우.
둘째, 최단 경로 P에 "중복 노드"가 1개 존재하는 경우.
셋째, 최단 경로 P에 "중복 노드"가 2개 이상 존재하는 경우.

첫번째 경우, 최단 경로에 "중복 노드"가 포함되지 않기 때문에, 재방문 유/무는 최단거리 계산에 전혀 영향을 주지 못함이 명백하다. 그렇기에 살포시 넘어가자.

이 글의 핵심은, 둘째와 셋째의 경우에서도, 재방문은 최단거리 계산과 상관없음을 보이는것이다.
이를 위해서,
두번째 경우, 재방문 유/무가 최단거리 계산에 전혀 영향을 주지 못하고,
세번째 경우, 두번째 경우를 재귀적으로 확장하여(수학적 귀납법) 증명하고자 한다.

두번째 경우

최단 경로 P에 "중복 노드"가 1개 존재하기 때문에, "중복 노드"의 정의에 의해, 아래와 같은 경로 2개가 존재한다.
경로1: "시작 노드" -> ... -> 노드1 -> "중복 노드" -> ... -> "목표 노드"
경로2: "시작 노드" -> ... -> 노드2 -> "중복 노드" -> ... -> "목표 노드"
이 때, 노드1과 노드2는 같지 않다.
일반성을 잃지 않고, 노드1을 통해 "중복 노드"에 먼저 방문했다고 가정하자.
그렇다면, 노드2를 통해서 "중복 노드"에 방문하는 일은 없기에, 경로2가 누락되는것처럼 보일 수 있다.
하지만, 노드2에 도달했을 때, "중복 노드"에 방문하지 않더라도, 노드2와 "중복 노드" 사이의 거리를 계산할 수 있다( [노드2 -> "중복 노드"] 에지의 weight가 해당 거리이다). 그렇기에, 누락되지 않는다.

이를 두개의 경우 2-1과 2-2로 더 나누어 살펴보자.

경우 2-1: 노드2와 "중복 노드" 사이의 거리가, 노드1과 "중복 노드" 사이의 거리보다 긴 경우.
이 경우에는, 노드2와 "중복 노드" 사이의 거리에 대해 알던 모르던 전혀 상관없다. 노드1을 지나는 경로가 더 짧은 경로이기 때문에, "시작 노드" -> ... -> 노드1 의 거리에서 노드1 -> "중복 노드" 의 거리를 더하면 "시작 노드" -> ... -> "중복 노드"의 최단 거리가 된다.
경우 2-2: 노드2와 "중복 노드" 사이의 거리가, 노드1과 "중복 노드"사이의 거리보다 짧은 경우.
이 경우에는, "시작 노드" -> ... -> "노드2"의 거리에, "노드2" -> "중복 노드"의 거리를 더하면, "시작 노드" -> ... -> "중복 노드"의 최단거리가 된다.
위에서 보듯이, 어떤 경우에서던 "시작 노드"부터 "중복 노드"까지의 최단거리를 계산할 수 있다. 나머지 "중복 노드"부터 "목표 노드"까지의 경로에 다른 "중복 노드"는 없기 때문에, 재방문을 막는것이 최단 거리 계산에 영향을 미칠 수 없다.

세번째 경우

최단 경로 P에 "중복 노드"가 2개 이상 존재하기 때문에, P는 아래와 같은 형태를 갖게 된다.
최단 경로 P: "시작 노드" -> ... -> 노드3 -> "중복 노드"1 -> ... -> "중복 노드"2 -> ... -> 노드4 -> "중복 노드"N -> ... -> "목표 노드"

수학적 귀납법의 사용을 위해, 위의 최단 경로에서, "시작 노드"부터 "중복 노드"N-1까지의 최단 거리를 계산할 수 있다 가정하자.

이 때, "중복 노드"N-1부터 "중복 노드"N까지의 최단 거리를 계산할 수 있음을 보이면, 이 증명은 완료됨에 주목하자.

"중복 노드"2에서 부터 노드4 까지의 최단 경로에 다른 "중복 노드"는 없다. 그렇기에, "중복 노드"2부터 노드4까지의 최단 거리와 재방문의 방지는 연관이 없다. 또한, 노드4 부터 "중복 노드"N의 거리는 두번째 경우에서 봤듯이 쉽게 알아낼 수 있다.
그러면, "중복 노드"2부터 노드4까지의 최단 거리에, 노드4 부터 "중복 노드"N까지의 거리를 더하면, "시작 노드"에서 "중복노드"N까지의 최단 거리를 알아낼 수 있다.

"중복 노드"가 1개 있을 경우, 재방문하지 않아도 최단 거리를 계산할 수 있음을 보였다(base case). 또한, "중복 노드"가 N-1개 있을 때 최단거리를 계산할 수 있다면, "중복 노드"가 N개 있을 때 최단 거리를 계산할 수 있다는것도 보았다.

증명종료.

